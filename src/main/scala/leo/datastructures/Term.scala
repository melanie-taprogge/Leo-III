package leo.datastructures

import scala.language.implicitConversions

/**
 * Abstract interface for terms and operations on them that can be
 * done in the internal language.
 * Terms are generated by
 *
 * {{{s,t ::= i (bound symbol)
 *       | c (constant symbol)
 *       | λ:tau.s (term abstraction)
 *       | s t (term application)
 *       | Λs (type abstraction)
 *       | s tau (type application)}}}
 *
 * where `c` is some symbol (constant) and `tau` is a type (see `Type`).
 *
 * @author Alexander Steen
 * @since 21.05.2014
 * @note Updated 02.06.2014 Cleaned up method set, lambda terms always have types
 * @note Updated 09.06.2014 Added pattern matcher for terms, added definition expansion
 */
trait Term extends Pretty with Prettier {
  // Predicates on terms
  /** Returns true iff `this` is either a constant or a variable, i.e. `isConstant || isVariable || isNumber`. */
  def isAtom: Boolean
  /** Returns true iff `this` is a constant from the signature as a term (i.e. TermApp(c,Nil) where c is a constant). */
  def isConstant: Boolean
  /** Returns true iff `this` is a (free/bound/loose bound) variable. */
  def isVariable: Boolean

  def isNumber: Boolean
  /** Returns true iff `this` is an abstraction (λ. t') for some term t'. */
  def isTermAbs: Boolean
  /** Returns true iff `this` is a type abstraction (Λ. t') for some term t'. */
  def isTypeAbs: Boolean
  /** Returns trie iff `this` is an application h ∙ args. */
  def isApp: Boolean
  def flexHead: Boolean
  /** `true` is the term is known to be in beta-normal form, else false.
    * @note Might return false if the term is in beta normal form but .betaNormalize was never invoked in it. */
  def isBetaNormal: Boolean
  def isEtaNormal: Boolean

  /** Create the term application `this @ arg`. */
  def apply(arg: Term): Term = Term.local.mkTermApp(this, arg)
  /** Create the term application `this @ arg1 @ args1 @ args2 .... @ argsn`. */
  def apply(arg1: Term, args: Term*): Term = Term.local.mkTermApp(this, arg1 +: args)

  type Sharing = Boolean
  def sharing: Sharing

  //////////////////////////
  // Handling def. expansion
  //////////////////////////

  /** Returns true iff any subterm of this term can be expanded by its definition. */
  def δ_expandable(implicit sig: Signature): Boolean
  /** Exhaustively expands all defined subterms (i.e. defined symbols) by its definitions.
    * This may not terminate for recursively defined symbols. */
  def δ_expand(implicit sig: Signature): Term
  /** Expands defined subterms as `δ_expand` but with at most `rep` recursive replacements. */
  def δ_expand(rep: Int)(implicit sig: Signature): Term
  /** Exhaustively expands all symbols except for those in `symbs` which are
    * defined by its definitions.
    * This may not terminate for recursively defined symbols. */
  def δ_expand_upTo(symbs: Set[Signature.Key])(implicit sig: Signature): Term

  def δ_expand_andTrack_upTo(symbs: Set[Signature.Key])(implicit sig: Signature): (Term, Seq[Signature.Key])

  //////////////////////////
  // Queries on terms
  //////////////////////////
  /** Returns the type of the term */
  def ty: Type
  /** Returns the free occurrences of variables as tuple (index, type). */
  def fv: Set[(Int, Type)]
  /** Same as `fv`, just that it returns the free occurences of variables
    * as terms. */
  final def freeVars: Set[Term] = fv.map(v => Term.mkBound(v._2, v._1))
  /** Same as `fv`, just that it returns the free occurences of variables
    * as de-bruijn indices. */
  final def looseBounds: Set[Int] = fv.map(_._1)
  /** true iff the term does not contain any free variables. */
  final def ground: Boolean = fv.isEmpty
  /** Returns the free occurrences of type variables. */
  def tyFV: Set[Int]
  def feasibleOccurrences: Map[Term, Set[Position]]
  def headSymbol: Term
  def headSymbolDepth: Int
  def size: Int

//  /** Given a position `pos`, return the subterm of `this`
//    * at `pos`, if existent. `null` otherwise. */
//  def subterm(pos: Position): Term

  /** Multiset of all symbols contained within the term. */
  def symbols: Multiset[Signature.Key]
  /** Multiset of all free variables contained within the term. */
  def vars: Multiset[Int]
  def headVars: Set[Int]

  // Functions for FV-Indexing
  def fvi_symbolFreqOf(symbol: Signature.Key): Int
  def fvi_symbolDepthOf(symbol: Signature.Key): Int

  // Substitutions and replacements
  /** Replace every occurrence of `what` in `this` by `by`. */
  def replace(what: Term, by: Term): Term
  def replaceAt(at: Position, by: Term): Term

  /** Apply substitution `subst` to underlying term.
    * I.e. each free variable `i` (NOT meta-vars!) occurring within `this` is replaced by `subst(i)`,
    * The term is then beta normalized */
  final def substitute(termSubst: Subst, typeSubst: Subst = Subst.id): Term =
    if (termSubst == Subst.id && typeSubst == Subst.id) this
    else closure(termSubst, typeSubst).betaNormalize
  final def termSubst(termSubst: Subst): Term = if (termSubst == Subst.id) this else closure(termSubst, Subst.id).betaNormalize
  final def typeSubst(typeSubst: Subst): Term = if (typeSubst == Subst.id) this else closure(Subst.id, typeSubst).betaNormalize
//  /** Apply type substitution `tySubst` to underlying term. */
//  def tySubstitute(tySubst: Subst): Term = this.tyClosure(tySubst).betaNormalize
  /** Apply a shifting substitution by `by`, i.e. return this.substitute(Subst.shift(by)).betanormalize*/
  final def lift(by: Int): Term = if (by == 0) this else substitute(Subst.shift(by)).betaNormalize
  final def lift(termLift: Int, typeLift: Int): Term = substitute(Subst.shift(termLift), Subst.shift(typeLift)).betaNormalize

  /** Explicitly create a closure, i.e. a postponed (simultaneous) substitution (of types and terms) */
  def closure(termSubst: Subst, typeSubst: Subst): Term
  /** Explicitly create a term closure, i.e. a postponed substitution */
  def termClosure(subst: Subst): Term
  /** Explicitly create a term closure with underlying type substitution `tySubst`. */
  def typeClosure(subst: Subst): Term

  // Other operations
  final def compareTo(that: Term)(implicit sig: Signature): CMP_Result = leo.Configuration.TERM_ORDERING.compare(this, that)(sig)
  /** Return the β-nf of the term */
  def betaNormalize: Term
  /** Return the eta-long-nf of the term */
  def etaExpand: Term
  /** Return the eta-short-nf of the term */
  def etaContract: Term
}

/////////////////////////////
// Associated traits, exceptions, ...
/////////////////////////////

class NotWellTypedException(msg: String, term: Option[Term]) extends RuntimeException(msg) {
  def this(msg: String) = {
    this(msg, None)
  }
}
object NotWellTypedException {
  final def apply(): NotWellTypedException = new NotWellTypedException("", None)
  final def apply(msg: String): NotWellTypedException = new NotWellTypedException(msg, None)
  final def apply(term: Term): NotWellTypedException = new NotWellTypedException(term.pretty, Some(term))
  final def apply(msg: String, term: Term): NotWellTypedException = new NotWellTypedException(msg, Some(term))
}

/////////////////////////////
// Companion factory object
/////////////////////////////
/**
 * Term Factory object. Only this class is used to create new terms.
 *
 * Current default term implementation: [[impl.TermImpl]]
 */
object Term extends TermBank {
  import impl.TermImpl

  // Factory method delegation
  override final def mkAtom(id: Signature.Key)(implicit sig: Signature): Term = TermImpl.mkAtom(id)(sig)
  override final def mkAtom(id: Signature.Key, ty: Type): Term = TermImpl.mkAtom(id,ty)
  override final def mkBound(t: Type, scope: Int): Term = TermImpl.mkBound(t,scope)
  override final def mkInteger(n: BigInt): Term = TermImpl.mkInteger(n)
  override final def mkRational(numerator: BigInt, denominator: BigInt): Term = TermImpl.mkRational(numerator,denominator)
  override final def mkReal(wholePart: BigInt, decimalPart: BigInt, exponent: BigInt): Term = TermImpl.mkReal(wholePart, decimalPart, exponent)
  override final def mkTermApp(func: Term, arg: Term): Term = TermImpl.mkTermApp(func, arg)
  override final def mkTermApp(func: Term, args: Seq[Term]): Term = TermImpl.mkTermApp(func, args)
  override final def mkTermAbs(t: Type, body: Term): Term = TermImpl.mkTermAbs(t, body)
  override final def mkTypeApp(func: Term, arg: Type): Term = TermImpl.mkTypeApp(func, arg)
  override final def mkTypeApp(func: Term, args: Seq[Type]): Term = TermImpl.mkTypeApp(func, args)
  override final def mkTypeAbs(body: Term): Term = TermImpl.mkTypeAbs(body)
  override final def mkApp(func: Term, args: Seq[Either[Term, Type]]): Term = TermImpl.mkApp(func, args)

  // Term bank method delegation
  override final val local: TermFactory = TermImpl.local
  override final def insert(term: Term): Term = TermImpl.insert(term)
  override final def reset(): Unit = TermImpl.reset()

  // Utility
  /** Checks if a term is well-typed. Does does check whether free variables
    * are consistently typed. */
  final def wellTyped(t: Term): Boolean = {
    try {
      TermImpl.wellTyped(t.asInstanceOf[TermImpl])
    } catch {
      case e: NotWellTypedException =>
        leo.Out.severe(s"Term ${t.pretty} not well typed:")
        leo.Out.severe(e.toString)
        false
    }
  }

  final def isLocal(t: Term): Boolean = !t.sharing
  final def isGlobal(t: Term): Boolean = t.sharing

  // Conversions
  /** Convert tuple (i,ty) to according de-Bruijn index */
  final implicit def intToBoundVar(in: (Int, Type)): Term = mkBound(in._2,in._1)
  /** Convert tuple (i,j) to according de-Bruijn index (where j is a type-de-Bruijn index) */
  final implicit def intsToBoundVar(in: (Int, Int)): Term = mkBound(in._2,in._1)


  //////////////////////////////////////////
  // Patterns for term structural matching
  //////////////////////////////////////////
  /**
   * Pattern for matching bound symbols in terms (i.e. De-Bruijn-Indices). Usage:
   * {{{
   * t match {
   *  case Bound(ty,scope) => println("Matched bound symbol of lambda-scope "
   *                                  + scope.toString + " with type "+ ty.pretty)
   *  case _               => println("something else")
   * }
   * }}}
   */
  final object Bound { def unapply(t: Term): Option[(Type, Int)] = TermImpl.boundMatcher(t) }

  /**
   * Pattern for matching constant symbols in terms (i.e. symbols in signature). Usage:
   * {{{
   * t match {
   *  case Symbol(constantKey) => println("Matched constant symbol "+ constantKey.toString)
   *  case _                   => println("something else")
   * }
   * }}}
   */
  final object Symbol { def unapply(t: Term): Option[Signature.Key] = TermImpl.symbolMatcher(t) }

  final object Integer { def unapply(t: Term): Option[Int0] = TermImpl.integerMatcher(t) }
  final object Rational { def unapply(t: Term): Option[Rat] = TermImpl.rationalMatcher(t) }
  final object Real { def unapply(t: Term): Option[Real] = TermImpl.realMatcher(t) }

  /**
   * Pattern for matching a general application (i.e. terms of form `(h ∙ S)`), where
   * `h` is the function term and `S` is a sequence of terms/types (arguments).
   * Usage:
   * {{{
   * t match {
   *  case s ∙ args => println("Matched application. Head: " + s.pretty
   *                                            + " Args: " + args.map.fold(_.pretty,_.pretty)).toString
   *  case _       => println("something else")
   * }
   * }}}
   */
  final object ∙ { def unapply(t: Term): Option[(Term, Seq[Either[Term, Type]])] = TermImpl.appMatcher(t) }

  /**
   * Pattern for matching a term application (i.e. terms of form `(h ∙ S)`), where
   * `h` is the function term and `S` is a sequence of terms only (arguments).
   * Usage:
   * {{{
   * t match {
   *  case s ∙ args => println("Matched application. Head: " + s.pretty
   *                                            + " Args: " + args.map.fold(_.pretty,_.pretty)).toString
   *  case _       => println("something else")
   * }
   * }}}
   */
  final object TermApp {
    def unapply(t: Term): Option[(Term, Seq[Term])] = t match {
      case h ∙ sp => if (sp.forall(_.isLeft)) {
                        Some(h, sp.map(_.left.get))
                      } else None
      case _ => None
    }
  }

  /**
   * Pattern for matching a type application (i.e. terms of form `(h ∙ S)`), where
   * `h` is the function term and `S` is a sequence of types only (arguments).
   * Usage:
   * {{{
   * t match {
   *  case s ∙ args => println("Matched application. Head: " + s.pretty
   *                                            + " Args: " + args.map.fold(_.pretty,_.pretty)).toString
   *  case _       => println("something else")
   * }
   * }}}
   */
  final object TypeApp {
    def unapply(t: Term): Option[(Term, Seq[Type])] = t match {
      case h ∙ sp => if (sp.forall(_.isRight)) {
        Some(h, sp.map(_.right.get))
      } else None
      case _ => None
    }
  }

  /**
   * Pattern for matching (term) abstractions in terms (i.e. terms of form `(\(ty)(s))` where `ty` is a type). Usage:
   * {{{
   * t match {
   *  case ty :::> s => println("Matched abstraction. Type of parameter: " + ty.pretty
   *                                                           + " Body: " + s.pretty)
   *  case _         => println("something else")
   * }
   * }}}
   */
  final object :::> { def unapply(t: Term): Option[(Type,Term)] = TermImpl.termAbstrMatcher(t) }

  /**
   * Pattern for matching (type) abstractions in terms (i.e. terms of form `/\(s)`). Usage:
   * {{{
   * t match {
   *  case TypeLambda(s) => println("Matched type abstraction. Body: " + s.pretty)
   *  case _             => println("something else")
   * }
   * }}}
   */
  final object TypeLambda { def unapply(t: Term): Option[Term] = TermImpl.typeAbstrMatcher(t) }
}
